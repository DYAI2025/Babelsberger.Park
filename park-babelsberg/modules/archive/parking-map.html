<!-- Parkplatz-Finder Map Module -->
<!-- Integration: Füge diesen Block in index.html unterhalb der "Gastronomie-Finder"-Section ein -->

<section id="parkplatz-finder" class="section">
  <h2>Parkplatz-Finder</h2>
  <p style="margin-bottom:20px;color:var(--text-muted)">
    Finde Parkplätze in der Nähe des Parks. Nutze deinen Standort für Navigation.
  </p>

  <div class="card" style="padding:0;overflow:hidden;">
    <!-- Map Container -->
    <div id="parking-map" style="height:400px;width:100%;background:#e2e8f0;"></div>

    <!-- Controls -->
    <div style="padding:calc(var(--grid) * 2);display:flex;gap:calc(var(--grid) * 1.5);flex-wrap:wrap;align-items:center;">
      <button id="btn-parking-locate" class="parking-btn parking-btn-primary">
        📍 Standort nutzen
      </button>
      <button id="btn-parking-nearest" class="parking-btn parking-btn-secondary" disabled>
        🧭 Zum nächsten Parkplatz
      </button>
      <span id="parking-distance-info" style="color:var(--text-muted);font-size:0.9rem;margin-left:auto;"></span>
    </div>

    <!-- Info Notice -->
    <div class="notice" style="margin:0 calc(var(--grid) * 2) calc(var(--grid) * 2);">
      <small>
        <strong>Legende:</strong>
        🅿️ Öffentlich · 💰 Kostenpflichtig · 🔒 Privat/Kunden · 🏢 Parkhaus · 🚲 Fahrrad<br>
        <strong>Datenquelle:</strong> OpenStreetMap ·
        <strong>Navigation:</strong> Öffnet Google Maps
      </small>
    </div>
  </div>
</section>

<!-- Parking Map Styles -->
<style>
  .parking-btn {
    padding: 12px 20px;
    border: none;
    border-radius: var(--radius-sm);
    font-family: var(--font-body);
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-base);
    white-space: nowrap;
  }

  .parking-btn-primary {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    color: var(--text-inverse);
    box-shadow: var(--shadow-sm);
  }

  .parking-btn-primary:hover:not(:disabled) {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
  }

  .parking-btn-secondary {
    background: var(--bg-secondary);
    color: var(--accent-primary);
    border: 1px solid var(--accent-primary);
  }

  .parking-btn-secondary:hover:not(:disabled) {
    background: var(--accent-primary);
    color: var(--text-inverse);
  }

  .parking-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Mobile optimization */
  @media (max-width: 768px) {
    #parking-map {
      height: 320px;
    }

    .parking-btn {
      flex: 1;
      min-width: 140px;
    }

    #parking-distance-info {
      flex-basis: 100%;
      margin-left: 0 !important;
      text-align: center;
    }
  }
</style>

<!-- Parking Map Script -->
<script>
(function() {
  'use strict';

  // Configuration
  const CONFIG = {
    dataPath: 'data/parking.geojson',
    defaultCenter: [52.400, 13.075],
    defaultZoom: 13,
    maxZoom: 19,
    tileLayer: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
    tileAttribution: '© OpenStreetMap contributors'
  };

  // Parking type colors
  const PARKING_COLORS = {
    'bicycle_parking': '#10b981',  // Green for bicycles
    'public_free': '#3b82f6',      // Blue for public free
    'public_paid': '#f59e0b',      // Orange for paid
    'private': '#6b7280',          // Gray for private/customers
    'multi-storey': '#1e3a8a'      // Dark blue for multi-storey
  };

  // State
  let map = null;
  let userPos = null;
  let markers = [];
  let userMarker = null;

  // DOM Elements
  const btnLocate = document.getElementById('btn-parking-locate');
  const btnNearest = document.getElementById('btn-parking-nearest');
  const distanceInfo = document.getElementById('parking-distance-info');

  // Initialize Map
  function initMap() {
    map = L.map('parking-map', {
      zoomControl: true,
      attributionControl: true
    });

    L.tileLayer(CONFIG.tileLayer, {
      maxZoom: CONFIG.maxZoom,
      attribution: CONFIG.tileAttribution
    }).addTo(map);

    map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
  }

  // Load Parking Data
  async function loadParkingData() {
    try {
      const response = await fetch(CONFIG.dataPath);
      const geojson = await response.json();

      if (!geojson.features || geojson.features.length === 0) {
        console.warn('Keine Parkplatz-Daten gefunden');
        return;
      }

      // Fit map to data bounds
      const bounds = calculateBounds(geojson);
      if (bounds) {
        map.fitBounds(bounds, { padding: [50, 50] });
      }

      // Add markers
      geojson.features.forEach(addParkingMarker);

    } catch (error) {
      console.error('Fehler beim Laden der Parkplatz-Daten:', error);
    }
  }

  // Calculate GeoJSON bounds
  function calculateBounds(geojson) {
    if (!geojson.features || geojson.features.length === 0) return null;

    let minLat = 90, minLng = 180, maxLat = -90, maxLng = -180;

    geojson.features.forEach(feature => {
      const [lng, lat] = feature.geometry.coordinates;
      if (lat < minLat) minLat = lat;
      if (lat > maxLat) maxLat = lat;
      if (lng < minLng) minLng = lng;
      if (lng > maxLng) maxLng = lng;
    });

    return [[minLat, minLng], [maxLat, maxLng]];
  }

  // Determine parking category for color coding
  function getParkingCategory(props) {
    if (props.amenity === 'bicycle_parking') return 'bicycle_parking';
    if (props.parking === 'multi-storey') return 'multi-storey';
    if (props.access === 'private' || props.access === 'customers') return 'private';
    if (props.fee === 'yes') return 'public_paid';
    if (props.fee === 'no') return 'public_free';
    return 'public_free'; // default
  }

  // Add Parking marker to map
  function addParkingMarker(feature) {
    const [lng, lat] = feature.geometry.coordinates;
    const props = feature.properties || {};

    const category = getParkingCategory(props);
    const icon = getMarkerIcon(category);

    const marker = L.marker([lat, lng], { icon }).addTo(map);

    // Popup content
    let popupContent = `<strong>${props.name || 'Parkplatz'}</strong><br>`;

    if (props.amenity === 'bicycle_parking') {
      popupContent += '🚲 Fahrradparkplatz<br>';
    } else {
      popupContent += '🅿️ Auto-Parkplatz<br>';

      if (props.parking) {
        const typeLabels = {
          'surface': 'Oberirdisch',
          'underground': 'Tiefgarage',
          'multi-storey': 'Parkhaus',
          'street_side': 'Straßenrand'
        };
        popupContent += `📍 ${typeLabels[props.parking] || props.parking}<br>`;
      }

      if (props.capacity) {
        popupContent += `🚗 Kapazität: ${props.capacity} Plätze<br>`;
      }
    }

    // Fee status
    if (props.fee === 'yes') {
      popupContent += '💰 Kostenpflichtig<br>';
    } else if (props.fee === 'no') {
      popupContent += '✓ Kostenlos<br>';
    }

    // Access
    if (props.access === 'private') {
      popupContent += '🔒 Privat<br>';
    } else if (props.access === 'customers') {
      popupContent += '🔒 Nur für Kunden<br>';
    }

    if (props.wheelchair === 'yes') {
      popupContent += '♿ Barrierefrei<br>';
    }

    if (props.maxstay) {
      popupContent += `⏱️ Max. Parkdauer: ${props.maxstay}<br>`;
    }

    marker.bindPopup(popupContent);

    markers.push({ lat, lng, props, marker, category });
  }

  // Get marker icon based on category
  function getMarkerIcon(category) {
    const color = PARKING_COLORS[category] || '#3b82f6';

    return L.divIcon({
      className: 'custom-marker',
      html: `<div style="
        width: 24px;
        height: 24px;
        background: ${color};
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      "></div>`,
      iconSize: [24, 24],
      iconAnchor: [12, 12]
    });
  }

  // Haversine distance calculation (meters)
  function haversine(pos1, pos2) {
    const R = 6371000; // Earth radius in meters
    const toRad = x => x * Math.PI / 180;

    const dLat = toRad(pos2.lat - pos1.lat);
    const dLng = toRad(pos2.lng - pos1.lng);
    const lat1 = toRad(pos1.lat);
    const lat2 = toRad(pos2.lat);

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(dLng/2) * Math.sin(dLng/2);

    return 2 * R * Math.asin(Math.sqrt(a));
  }

  // Find nearest Parking (prioritize car parking over bicycle)
  function findNearestParking() {
    if (!userPos || markers.length === 0) return null;

    let nearest = null;
    let minDistance = Infinity;

    // Prioritize car parking
    const carParking = markers.filter(p => p.props.amenity !== 'bicycle_parking');
    const searchList = carParking.length > 0 ? carParking : markers;

    searchList.forEach(parking => {
      const distance = haversine(
        { lat: userPos.lat, lng: userPos.lng },
        { lat: parking.lat, lng: parking.lng }
      );

      if (distance < minDistance) {
        minDistance = distance;
        nearest = { ...parking, distance };
      }
    });

    return nearest;
  }

  // Format distance
  function formatDistance(meters) {
    if (meters < 1000) {
      return `${Math.round(meters)} m`;
    }
    return `${(meters / 1000).toFixed(1)} km`;
  }

  // Check CMP consent (stub integration)
  function checkGeolocationConsent() {
    // TODO: Integrate with real CMP
    // For now, we use browser's native geolocation permission
    return true;
  }

  // Locate user
  function locateUser() {
    if (!navigator.geolocation) {
      alert('Geolocation wird von deinem Browser nicht unterstützt.');
      return;
    }

    // Check consent
    if (!checkGeolocationConsent()) {
      alert('Bitte erlaube Standortzugriff in den Datenschutzeinstellungen.');
      return;
    }

    btnLocate.disabled = true;
    btnLocate.textContent = '⏳ Standort wird ermittelt...';

    navigator.geolocation.getCurrentPosition(
      position => {
        userPos = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        // Remove old user marker if exists
        if (userMarker) {
          map.removeLayer(userMarker);
        }

        // Add user marker
        userMarker = L.circleMarker([userPos.lat, userPos.lng], {
          radius: 8,
          fillColor: '#ef4444',
          color: '#fff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.8
        }).addTo(map);

        userMarker.bindPopup('<strong>📍 Dein Standort</strong>').openPopup();

        // Center map on user
        map.setView([userPos.lat, userPos.lng], 15);

        // Enable navigation button
        btnNearest.disabled = false;
        btnLocate.textContent = '✓ Standort aktiv';

        // Show distance to nearest parking
        const nearest = findNearestParking();
        if (nearest) {
          distanceInfo.textContent = `Nächster Parkplatz: ${formatDistance(nearest.distance)}`;
        }
      },
      error => {
        btnLocate.disabled = false;
        btnLocate.textContent = '📍 Standort nutzen';

        let message = 'Standortzugriff fehlgeschlagen. ';

        switch(error.code) {
          case error.PERMISSION_DENIED:
            message += 'Bitte erlaube Standortzugriff in deinem Browser.';
            break;
          case error.POSITION_UNAVAILABLE:
            message += 'Standort konnte nicht ermittelt werden.';
            break;
          case error.TIMEOUT:
            message += 'Zeitüberschreitung. Bitte versuche es erneut.';
            break;
          default:
            message += 'Unbekannter Fehler.';
        }

        alert(message);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  }

  // Navigate to nearest Parking (platform-aware)
  function navigateToNearest() {
    if (!userPos || markers.length === 0) return;

    const nearest = findNearestParking();
    if (!nearest) {
      alert('Kein Parkplatz in der Nähe gefunden.');
      return;
    }

    const origin = `${userPos.lat},${userPos.lng}`;
    const destination = `${nearest.lat},${nearest.lng}`;

    // Platform detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);

    let url;

    if (isMobile) {
      if (isIOS) {
        // iOS: Try Apple Maps first, fallback to Google Maps
        url = `maps://maps.apple.com/?saddr=${origin}&daddr=${destination}&dirflg=d`;

        // Fallback to Google Maps if Apple Maps not available
        setTimeout(() => {
          window.location.href = `https://maps.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=driving`;
        }, 500);
      } else if (isAndroid) {
        // Android: Use geo: URI which opens default maps app
        url = `geo:${destination}?q=${destination}(Parkplatz)`;
      } else {
        // Other mobile: Google Maps mobile web
        url = `https://maps.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=driving`;
      }

      window.location.href = url;
    } else {
      // Desktop: Open in new tab
      url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=driving`;
      window.open(url, '_blank', 'noopener,noreferrer');
    }
  }

  // Event Listeners
  btnLocate.addEventListener('click', locateUser);
  btnNearest.addEventListener('click', navigateToNearest);

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      loadParkingData();
    });
  } else {
    initMap();
    loadParkingData();
  }
})();
</script>

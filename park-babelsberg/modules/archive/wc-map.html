<!-- WC-Finder Map Module -->
<!-- Integration: F√ºge diesen Block in index.html unterhalb der "Praktisches vor Ort"-Section ein -->

<section id="wc-finder" class="section">
  <h2>WC-Finder</h2>
  <p style="margin-bottom:20px;color:var(--text-muted)">
    Finde schnell das n√§chste WC im Park. Nutze deinen Standort f√ºr Navigation.
  </p>

  <div class="card" style="padding:0;overflow:hidden;">
    <!-- Map Container -->
    <div id="wc-map" style="height:400px;width:100%;background:#e2e8f0;"></div>

    <!-- Controls -->
    <div style="padding:calc(var(--grid) * 2);display:flex;gap:calc(var(--grid) * 1.5);flex-wrap:wrap;align-items:center;">
      <button id="btn-locate" class="wc-btn wc-btn-primary">
        üìç Standort nutzen
      </button>
      <button id="btn-nearest" class="wc-btn wc-btn-secondary" disabled>
        üß≠ Zum n√§chsten WC
      </button>
      <span id="distance-info" style="color:var(--text-muted);font-size:0.9rem;margin-left:auto;"></span>
    </div>

    <!-- Info Notice -->
    <div class="notice" style="margin:0 calc(var(--grid) * 2) calc(var(--grid) * 2);">
      <small>
        <strong>Legende:</strong>
        üü¢ √ñffentlich zug√§nglich ¬∑ üü° Nur f√ºr Kunden ¬∑
        üí∞ Kostenpflichtig<br>
        <strong>Datenquelle:</strong> OpenStreetMap ¬∑
        <strong>Navigation:</strong> √ñffnet Google Maps
      </small>
    </div>
  </div>
</section>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous">

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>

<!-- WC Map Styles -->
<style>
  .wc-btn {
    padding: 12px 20px;
    border: none;
    border-radius: var(--radius-sm);
    font-family: var(--font-body);
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-base);
    white-space: nowrap;
  }

  .wc-btn-primary {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    color: var(--text-inverse);
    box-shadow: var(--shadow-sm);
  }

  .wc-btn-primary:hover:not(:disabled) {
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
  }

  .wc-btn-secondary {
    background: var(--bg-secondary);
    color: var(--accent-primary);
    border: 1px solid var(--accent-primary);
  }

  .wc-btn-secondary:hover:not(:disabled) {
    background: var(--accent-primary);
    color: var(--text-inverse);
  }

  .wc-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Leaflet popup customization */
  .leaflet-popup-content-wrapper {
    border-radius: var(--radius-sm);
    box-shadow: var(--shadow-lg);
  }

  .leaflet-popup-content {
    font-family: var(--font-body);
    margin: 16px;
  }

  /* Mobile optimization */
  @media (max-width: 768px) {
    #wc-map {
      height: 320px;
    }

    .wc-btn {
      flex: 1;
      min-width: 140px;
    }

    #distance-info {
      flex-basis: 100%;
      margin-left: 0 !important;
      text-align: center;
    }
  }
</style>

<!-- WC Map Script -->
<script>
(function() {
  'use strict';

  // Configuration
  const CONFIG = {
    dataPath: 'data/wc.geojson',
    defaultCenter: [52.395, 13.089], // Park Babelsberg
    defaultZoom: 15,
    maxZoom: 19,
    tileLayer: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
    tileAttribution: '¬© OpenStreetMap contributors'
  };

  // State
  let map = null;
  let userPos = null;
  let markers = [];
  let userMarker = null;

  // DOM Elements
  const mapEl = document.getElementById('wc-map');
  const btnLocate = document.getElementById('btn-locate');
  const btnNearest = document.getElementById('btn-nearest');
  const distanceInfo = document.getElementById('distance-info');

  // Initialize Map
  function initMap() {
    map = L.map('wc-map', {
      zoomControl: true,
      attributionControl: true
    });

    L.tileLayer(CONFIG.tileLayer, {
      maxZoom: CONFIG.maxZoom,
      attribution: CONFIG.tileAttribution
    }).addTo(map);

    map.setView(CONFIG.defaultCenter, CONFIG.defaultZoom);
  }

  // Load WC Data
  async function loadWCData() {
    try {
      const response = await fetch(CONFIG.dataPath);
      const geojson = await response.json();

      if (!geojson.features || geojson.features.length === 0) {
        console.warn('Keine WC-Daten gefunden');
        return;
      }

      // Fit map to data bounds
      const bounds = calculateBounds(geojson);
      if (bounds) {
        map.fitBounds(bounds, { padding: [50, 50] });
      }

      // Add markers
      geojson.features.forEach(addWCMarker);

    } catch (error) {
      console.error('Fehler beim Laden der WC-Daten:', error);
    }
  }

  // Calculate GeoJSON bounds
  function calculateBounds(geojson) {
    if (!geojson.features || geojson.features.length === 0) return null;

    let minLat = 90, minLng = 180, maxLat = -90, maxLng = -180;

    geojson.features.forEach(feature => {
      const [lng, lat] = feature.geometry.coordinates;
      if (lat < minLat) minLat = lat;
      if (lat > maxLat) maxLat = lat;
      if (lng < minLng) minLng = lng;
      if (lng > maxLng) maxLng = lng;
    });

    return [[minLat, minLng], [maxLat, maxLng]];
  }

  // Add WC marker to map
  function addWCMarker(feature) {
    const [lng, lat] = feature.geometry.coordinates;
    const props = feature.properties || {};

    // Determine marker icon based on access type
    const icon = getMarkerIcon(props.access, props.fee);

    const marker = L.marker([lat, lng], { icon }).addTo(map);

    // Popup content
    const popupContent = `
      <strong>${props.name || 'WC'}</strong><br>
      ${getAccessLabel(props.access)}<br>
      ${getFeeLabel(props.fee)}
    `;

    marker.bindPopup(popupContent);

    markers.push({ lat, lng, props, marker });
  }

  // Get marker icon based on access/fee
  function getMarkerIcon(access, fee) {
    let color = '#10b981'; // Green for public

    if (access === 'customers') {
      color = '#f59e0b'; // Yellow/orange for customers only
    } else if (fee === 'yes') {
      color = '#3b82f6'; // Blue for paid
    }

    return L.divIcon({
      className: 'custom-marker',
      html: `<div style="
        width: 24px;
        height: 24px;
        background: ${color};
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      "></div>`,
      iconSize: [24, 24],
      iconAnchor: [12, 12]
    });
  }

  // Get access label
  function getAccessLabel(access) {
    const labels = {
      'public': 'üü¢ √ñffentlich zug√§nglich',
      'yes': 'üü¢ √ñffentlich zug√§nglich',
      'permissive': 'üü¢ Zug√§nglich',
      'customers': 'üü° Nur f√ºr Kunden',
      'private': 'üî¥ Privat'
    };
    return labels[access] || 'üü¢ Zug√§nglich';
  }

  // Get fee label
  function getFeeLabel(fee) {
    if (fee === 'yes') return 'üí∞ Kostenpflichtig';
    if (fee === 'no') return '‚úì Kostenlos';
    return '‚ùì Kosten unbekannt';
  }

  // Haversine distance calculation (meters)
  function haversine(pos1, pos2) {
    const R = 6371000; // Earth radius in meters
    const toRad = x => x * Math.PI / 180;

    const dLat = toRad(pos2.lat - pos1.lat);
    const dLng = toRad(pos2.lng - pos1.lng);
    const lat1 = toRad(pos1.lat);
    const lat2 = toRad(pos2.lat);

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(dLng/2) * Math.sin(dLng/2);

    return 2 * R * Math.asin(Math.sqrt(a));
  }

  // Find nearest WC
  function findNearestWC() {
    if (!userPos || markers.length === 0) return null;

    let nearest = null;
    let minDistance = Infinity;

    markers.forEach(wc => {
      const distance = haversine(
        { lat: userPos.lat, lng: userPos.lng },
        { lat: wc.lat, lng: wc.lng }
      );

      if (distance < minDistance) {
        minDistance = distance;
        nearest = { ...wc, distance };
      }
    });

    return nearest;
  }

  // Format distance
  function formatDistance(meters) {
    if (meters < 1000) {
      return `${Math.round(meters)} m`;
    }
    return `${(meters / 1000).toFixed(1)} km`;
  }

  // Check CMP consent (stub integration)
  function checkGeolocationConsent() {
    // TODO: Integrate with real CMP
    // For now, we use browser's native geolocation permission
    return true;
  }

  // Locate user
  function locateUser() {
    if (!navigator.geolocation) {
      alert('Geolocation wird von deinem Browser nicht unterst√ºtzt.');
      return;
    }

    // Check consent
    if (!checkGeolocationConsent()) {
      alert('Bitte erlaube Standortzugriff in den Datenschutzeinstellungen.');
      return;
    }

    btnLocate.disabled = true;
    btnLocate.textContent = '‚è≥ Standort wird ermittelt...';

    navigator.geolocation.getCurrentPosition(
      position => {
        userPos = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };

        // Remove old user marker if exists
        if (userMarker) {
          map.removeLayer(userMarker);
        }

        // Add user marker
        userMarker = L.circleMarker([userPos.lat, userPos.lng], {
          radius: 8,
          fillColor: '#ef4444',
          color: '#fff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.8
        }).addTo(map);

        userMarker.bindPopup('<strong>üìç Dein Standort</strong>').openPopup();

        // Center map on user
        map.setView([userPos.lat, userPos.lng], 16);

        // Enable navigation button
        btnNearest.disabled = false;
        btnLocate.textContent = '‚úì Standort aktiv';

        // Show distance to nearest WC
        const nearest = findNearestWC();
        if (nearest) {
          distanceInfo.textContent = `N√§chstes WC: ${formatDistance(nearest.distance)}`;
        }
      },
      error => {
        btnLocate.disabled = false;
        btnLocate.textContent = 'üìç Standort nutzen';

        let message = 'Standortzugriff fehlgeschlagen. ';

        switch(error.code) {
          case error.PERMISSION_DENIED:
            message += 'Bitte erlaube Standortzugriff in deinem Browser.';
            break;
          case error.POSITION_UNAVAILABLE:
            message += 'Standort konnte nicht ermittelt werden.';
            break;
          case error.TIMEOUT:
            message += 'Zeit√ºberschreitung. Bitte versuche es erneut.';
            break;
          default:
            message += 'Unbekannter Fehler.';
        }

        alert(message);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  }

  // Navigate to nearest WC (platform-aware)
  function navigateToNearest() {
    if (!userPos || markers.length === 0) return;

    const nearest = findNearestWC();
    if (!nearest) {
      alert('Kein WC in der N√§he gefunden.');
      return;
    }

    const origin = `${userPos.lat},${userPos.lng}`;
    const destination = `${nearest.lat},${nearest.lng}`;

    // Platform detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);

    let url;

    if (isMobile) {
      if (isIOS) {
        // iOS: Try Apple Maps first, fallback to Google Maps
        url = `maps://maps.apple.com/?saddr=${origin}&daddr=${destination}&dirflg=w`;

        // Fallback to Google Maps if Apple Maps not available
        setTimeout(() => {
          window.location.href = `https://maps.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=walking`;
        }, 500);
      } else if (isAndroid) {
        // Android: Use geo: URI which opens default maps app
        url = `geo:${destination}?q=${destination}(WC)`;
      } else {
        // Other mobile: Google Maps mobile web
        url = `https://maps.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=walking`;
      }

      window.location.href = url;
    } else {
      // Desktop: Open in new tab
      url = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&travelmode=walking`;
      window.open(url, '_blank', 'noopener,noreferrer');
    }
  }

  // Event Listeners
  btnLocate.addEventListener('click', locateUser);
  btnNearest.addEventListener('click', navigateToNearest);

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      loadWCData();
    });
  } else {
    initMap();
    loadWCData();
  }
})();
</script>
